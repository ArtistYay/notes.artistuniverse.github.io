### Introduction

- **OAuth 2.0:** A widely used authorization framework that allows applications to access resources on behalf of a user without requiring their credentials.
- **Key Concepts:**
    - **Resource Owner:** The user or entity who owns the protected resources.
    - **Client:** The application requesting access to the resources.
    - **Authorization Server:** Issues access tokens to the client.
    - **Resource Server:** Stores and protects the resources.
    - **Authorization Grant:** Credentials used to obtain an access token.
    - **Access Token:** A credential used to access protected resources.
    - **Refresh Token:** Used to obtain a new access token without re-authentication.
    - **Redirect URI:** The URI where the authorization server redirects the user-agent after authorization.
    - **Scope:** Defines the level of access requested.
    - **State Parameter:** Protects against CSRF attacks.
    - **Token Endpoint:** Where the client exchanges the authorization grant for an access token.
    - **Authorization Endpoint:** Where the user authenticates and authorizes the client.
### OAuth 2.0 Grant Types

- **Authorization Code Grant:**
    
    - **Description:** The most secure and recommended flow for server-side web applications.
    - **Process:**
        1. The client redirects the user to the authorization server's authorization endpoint.
        2. The user authenticates and grants authorization.
        3. The authorization server redirects the user back to the client with an authorization code.
        4. The client exchanges the authorization code for an access token by making a POST request to the token endpoint.
    - **Security:** The authorization code is short-lived and only used once, reducing the risk of interception. The access token is never directly exposed to the user's browser.
    - **Refresh Tokens:** This flow supports the use of refresh tokens, allowing the client to obtain new access tokens without requiring the user to re-authenticate.
- **Implicit Grant:**
    
    - **Description:** Designed for clients that cannot securely store secrets, such as mobile apps and single-page web applications.
    - **Process:**
        1. The client redirects the user to the authorization server's authorization endpoint.
        2. The user authenticates and grants authorization.
        3. The authorization server redirects the user back to the client with an access token in the URL fragment.
    - **Security:** The access token is directly exposed to the user's browser, making it vulnerable to interception. This flow does not support refresh tokens.
    - **Recommendation:** This flow is now considered insecure and should be avoided.
- **Resource Owner Password Credentials Grant:**
    
    - **Description:** Used when the client is highly trusted by the resource owner, such as in first-party applications.
    - **Process:**
        1. The client collects the user's credentials (username and password) directly.
        2. The client sends the credentials to the authorization server's token endpoint.
        3. The authorization server verifies the credentials and issues an access token.
    - **Security:** This flow is less secure because it requires the user to share their credentials directly with the client. It should only be used for highly trusted applications.
- **Client Credentials Grant:**
    
    - **Description:** Used for server-to-server interactions where no user involvement is required.
    - **Process:**
        1. The client authenticates with the authorization server using its client credentials (client ID and secret).
        2. The authorization server issues an access token directly to the client.
    - **Security:** This flow is more secure for backend services as it does not involve user credentials.
- **Choosing the Right Grant Type:**
    
    - The choice of grant type depends on the type of client application and the level of security required.
    - For server-side web applications, the authorization code grant is the most secure and recommended option.
    - For mobile apps and single-page web applications, the authorization code grant with PKCE is the recommended option.
    - The implicit grant should be avoided due to its security vulnerabilities.
    - The resource owner password credentials grant should only be used for highly trusted first-party applications.
    - The client credentials grant is suitable for server-to-server interactions.
- **Additional Considerations:**
    
    - **PKCE (Proof Key for Code Exchange):** A security extension that can be used with the authorization code grant to protect against authorization code interception. It is highly recommended for public clients, such as mobile apps and single-page web applications.
    - **Refresh Tokens:** Refresh tokens should be used whenever possible to allow clients to obtain new access tokens without requiring the user to re-authenticate. This improves the user experience and reduces the risk of long-lived access tokens being compromised.
    - **Token Expiration:** Access tokens should have a limited lifespan to reduce the window of opportunity for attackers.
    - **Secure Token Storage:** Access tokens and refresh tokens should be stored securely to prevent unauthorized access.

By carefully considering the different grant types and implementing appropriate security measures, developers can ensure that their OAuth 2.0 implementations are secure and protect user data.
### OAuth 2.0 Workflow

1. **Authorization Request:**
    - The client redirects the user to the authorization server with parameters like `response_type`, `client_id`, `redirect_uri`, `scope`, and `state`.
2. **Authentication and Authorization:**
    - The user authenticates with the authorization server.
    - The user is prompted to grant access to the client.
3. **Authorization Response:**
    - If the user consents, the authorization server redirects the user back to the client with an authorization code and the state parameter.
4. **Token Request:**
    - The client exchanges the authorization code for an access token by making a POST request to the token endpoint.
5. **Token Response:**
    - The authorization server validates the request and issues an access token and, optionally, a refresh token.
### Identifying OAuth Usage

- **Login Options:** Look for "Login with [Provider]" options.
- **HTTP Redirects:** Analyze network traffic for redirects to authorization servers with OAuth parameters.
- **Identifying the Framework:**
    - Inspect HTTP headers and responses.
    - Analyze source code for specific libraries or frameworks.
    - Examine authorization and token endpoint patterns.
    - Look for clues in error messages.
### Exploiting Insecure Redirect URIs

- **Vulnerability:** If the `redirect_uri` is not properly validated, attackers can hijack tokens by controlling a registered URI.
- **Attacker's Strategy:**
    1. Gain control of a registered `redirect_uri`.
    2. Craft a malicious link with the attacker's `redirect_uri`.
    3. Trick the user into clicking the link.
    4. Intercept the authorization code or access token.
### CSRF Protection with the State Parameter

- **Purpose:** The `state` parameter prevents Cross-Site Request Forgery (CSRF) attacks by ensuring that the response matches the original request.
- **Vulnerability:** Weak or missing `state` parameters can allow attackers to hijack the OAuth flow.
### Exploiting Implicit Grant Flow

- **Weaknesses:**
    - Access token exposed in the URL fragment.
    - Inadequate validation of redirect URIs.
    - Lack of HTTPS enforcement.
    - Insecure storage of tokens.
- **Deprecation:** OAuth 2.1 recommends deprecating the implicit grant flow due to these vulnerabilities.
### Additional OAuth 2.0 Vulnerabilities

- **Insufficient Token Expiry:** Long-lived tokens increase the risk of unauthorized access.
- **Replay Attacks:** Capturing and reusing valid tokens.
- **Insecure Storage of Tokens:** Storing tokens in insecure locations (e.g., local storage).
### OAuth 2.1

- **Purpose:** Addresses security gaps and incorporates best practices from OAuth 2.0.
- **Major Changes:**
    - Deprecates the implicit grant type.
    - Mandates the `state` parameter.
    - Enforces secure token handling and storage.
    - Improves redirect URI validation and client authentication.